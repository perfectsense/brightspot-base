// site-wrapper is around the entire site includeing header, site, and footer
.site-wrapper {

}

// site is just around the site other than the header and footer
.site {
	background: @color-white;
	padding: @site-top-and-bottom-space 0;
	position: relative;
}

// fixed positioning offset if applicable
body {
	& when (@header-positioning = fixed) {
    	padding-top: @header-height;
    }

    // when we are a page that is rendererd embedded inside the styleguide, remove the padding
    &.body-embed {
        padding-top: 0;
    }
}

.layout-inverse-color {
    background: @color-component-inverse-background;
    color: @color-component-inverse-text;
}

.layout-secondary-color {
    background: @color-component-secondary-background;
}

// This will be our grid. We start out by creating our site container, which will determine the overall centered site width
.grid-container {
    .container();
    padding-left: @grid-gutter-width-xs / 2;
    padding-right: @grid-gutter-width-xs / 2;

    // when we reuse our layout renderers to create nested layouts, we end up with stacked
    // containers. This removes any styles from these, so we don't get doubled up margins, padding, etc
    .container {
    	width: 100%;
    	margin: 0;
    	padding: 0;
    }
}

.row {
	&:extend(.clearfix all);

	margin-left:  (@grid-gutter-width-xs / -2);
	margin-right: (@grid-gutter-width-xs / -2);
}

// With the below columns, we should be able to create most every layout necessary.
// We can always make more, but because we can make subgrids in columns, we can do a lot with just these
//
// If we need custom widths for a particular component, we can just use the mixin classes to create something
// custom for that one component. But if they will be reused throughout a site, we should create reusable classes

.column-full {
	// no styles, this is full on every breakpoint
	.make-xs-column(12);
}

.column-main {
	.make-sm-column(7);
	.make-md-column(8);
}

.column-aside {
	.make-sm-column(5);
	.make-md-column(4);
}

.column-half {
	.make-sm-column(6);

    // grid fix to make sure the 3th, 6th, etc columns wrap correctly
    &:nth-child(2n+1) {
        clear: left;
    }
}

.column-two-thirds {
	.make-sm-column(8);
}

// looks weird not being "three-quarters", but should be ok
.column-three-fourths {
    .make-sm-column(9);
}

.column-third {
	.make-sm-column(4);

    // grid fix to make sure the 4th, 7th, etc columns wrap correctly
    &:nth-child(3n+1) {
        clear: left;
    }
}

.column-fourth{
	.make-sm-column(3);

    // grid fix to make sure the 5th, 8th, etc columns wrap correctly
    &:nth-child(4n+1) {
        clear: left;
    }
}

.column-fifth {
	.make-sm-column(2.4);

    // grid fix to make sure the 6th, 9th, etc columns wrap correctly
    &:nth-child(5n+1) {
        clear: left;
    }
}

// The below styles create a fixed column to the left or to the right, depending on your markup. The column-fixed-wrap is there so that
// the fixed column knows where to place itself to the left and right. It has to get a hardcoded width, because that is how fixed
// positioning works

.column-scrolling {
	.make-md-column(9);
}

.column-fixed-wrap {
	.make-md-column(3);
}

.column-fixed {
	transition: height .15s linear;
	background: @color-white;
	border-top: @border-style-2;
	height: 50px;
    padding-top: 50px;
	position: fixed;
	left: 0;
	bottom: 0;
	width: 100%;
    z-index: @z-index-overlay-content;

	&.toggle-in {
		height: 75%;
		overflow-y: auto;

		@media @mq-only-sm {
			height: 25%;
		}
	}
}

body.column-fixed-toggle-in {
	overflow: hidden;

    &:before {
        content: ' ';
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0,0,0,0.7);
        z-index: @z-index-overlay;
    }
}

.trigger-fixed-column {

	a {
        .icon();

        background: @color-brand-primary;
        color: @color-white;
        display: block;
        left: 0;
        line-height: 50px;
        padding-left: @space;
		position: absolute;
        right: 0;
        text-transform: uppercase;
		top: 0;
        z-index: @z-index-base;

        &:after {
            font-size: @ts-1;
            position: absolute;
            right: @space;
        }
	}

	.toggle-trigger-link-out {
		display: block;

        &:after {
            content: @fa-var-angle-up;
        }
	}

	.toggle-trigger-link-in {
		display: none;

        &:after {
            content: @fa-var-angle-down;
        }
	}

	&.toggle-in {

		.toggle-trigger-link-out {
			display: none;
		}

		.toggle-trigger-link-in {
			display: block;
		}

	}


}

@media @mq-sm {

    .grid-container {
        .container();
        padding-left: @grid-gutter-width / 2;
        padding-right: @grid-gutter-width / 2;
    }

    .row {
        margin-left:  (@grid-gutter-width / -2);
        margin-right: (@grid-gutter-width / -2);
    }

    .column-fixed {
        &.toggle-in {
            height: 50%;
        }
    }

}

@media @mq-md {

	// styles to create a fixed column that will be stuck on the screen
	.column-fixed {
		border-top: none;
		bottom: auto;
		display: block;
		left: auto;
		margin-top: @site-top-and-bottom-space;
        padding: 0;
		// top: @header-tophat-height + @header-height;
		top: @header-height;
		// hardcoded width, as it needs to be as it's fixed positioning
		width: 240px;
        z-index: @z-index-base;
	}

	// since column is on the screen, we no longer need the toggle
	.trigger-fixed-column {
		display: none;
	}
}

@media @mq-lg {

	// up th width to match, has to stay hardcoded as it's fixed positioning
	.column-fixed {
		width: 317px;
	}

}
