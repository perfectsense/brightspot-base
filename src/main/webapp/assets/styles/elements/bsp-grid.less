// bsp-site-wrapper is around the entire site includeing header, site, and footer
.bsp-site-wrapper {}

/// bsp-site is just around the site other than the header and footer
.bsp-site {
	background: @white;
	padding: @site-top-and-bottom-space 0;
	position: relative;
}

// fixed positioning offset if applicable
body {
	& when (@header-positioning = fixed) {
    	padding-top: @header-tophat-height + (@header-height);
    }

    // when we are a page that is rendererd inside the styleguide, remove the padding
    &.sg-body {
        padding-top: 0;
    }
}


// This will be our grid. We start out by creating our site container, which will determine the overall centered site width
.bsp-container {
    .container();
    padding-left: @grid-gutter-width-xs / 2;
    padding-right: @grid-gutter-width-xs / 2;

    // when we reuse our layout renderers to create nested layouts, we end up with stacked
    // bsp-containers. This removes any styles from these, so we don't get doubled up margins, padding, etc
    .bsp-container {
    	width: 100%;
    	margin: 0;
    	padding: 0;
    }
}

.bsp-row {
	&:extend(.clearfix all);

	margin-left:  (@grid-gutter-width-xs / -2);
	margin-right: (@grid-gutter-width-xs / -2);
}

// With the below columns, we should be able to create most every layout necessary.
// We can always make more, but because we can make subgrids in columns, we can do a lot with just these
//
// If we need custom widths for a particular component, we can just use the mixin classes to create something
// custom for that one component. But if they will be reused throughout a site, we should create reusable classes

.bsp-column-full {
	// no styles, this is full on every breakpoint
	.make-xs-column(12);
}

.bsp-column-main {
	.make-sm-column(7);
	.make-md-column(8);
}

.bsp-column-aside {
	.make-sm-column(5);
	.make-md-column(4);
}

.bsp-column-half {
	.make-sm-column(6);
}

.bsp-column-two-thirds {
	.make-sm-column(8);
}

.bsp-column-third {
	.make-sm-column(4);
}

.bsp-column-fourth {
	.make-sm-column(3);
}

.bsp-column-fifth {
	.make-sm-column(2.4);
}

// The below styles create a fixed column to the left or to the right, depending on your markup. The column-fixed-wrap is there so that
// the fixed column knows where to place itself to the left and right. It has to get a hardcoded width, because that is how fixed
// positioning works

.bsp-column-scrolling {
	.make-md-column(9);
}

.bsp-column-fixed-wrap {
	.make-md-column(3);
}

.bsp-column-fixed {
	.transition(height .15s linear);

	background: @white;
	border-top: @border-style-2;
	height: 50px;
    padding-top: 50px;
	position: fixed;
	left: 0;
	bottom: 0;
	width: 100%;
    z-index: @z-index-overlay-content;

	&.toggle-in {
		height: 75%;
		overflow-y: auto;

		@media @mq-only-sm {
			height: 25%;
		}
	}

	// components inside of fixed columns lose their padding
	.bsp-component {
		padding: 0;
	}
}

body.bsp-column-fixed-toggle-in {
	overflow: hidden;

    &:before {
        content: ' ';
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0,0,0,0.7);
        z-index: @z-index-overlay;
    }
}

.bsp-trigger-fixed-column {

	a {
        .icon();

        background: @brand-primary;
        color: @white;
        display: block;
        left: 0;
        line-height: 50px;
        padding-left: @space;
		position: absolute;
        right: 0;
        text-transform: uppercase;
		top: 0;
        z-index: @z-index-base;

        &:after {
            font-size: @ts-1;
            position: absolute;
            right: @space;
        }
	}

	.toggle-trigger-link-out {
		display: block;

        &:after {
            content: @fa-var-angle-up;
        }
	}

	.toggle-trigger-link-in {
		display: none;

        &:after {
            content: @fa-var-angle-down;
        }
	}

	&.toggle-in {

		.toggle-trigger-link-out {
			display: none;
		}

		.toggle-trigger-link-in {
			display: block;
		}

	}


}

@media @mq-sm {

    .bsp-container {
        .container();
        padding-left: @grid-gutter-width / 2;
        padding-right: @grid-gutter-width / 2;
    }

    .bsp-row {
        margin-left:  (@grid-gutter-width / -2);
        margin-right: (@grid-gutter-width / -2);
    }

    .bsp-column-fixed {
        &.toggle-in {
            height: 50%;
        }
    }

}

@media @mq-md {

	// styles to create a fixed column that will be stuck on the screen
	.bsp-column-fixed {
		border-top: none;
		bottom: auto;
		display: block;
		left: auto;
		margin-top: @site-top-and-bottom-space;
        padding: 0;
		top: @header-tophat-height + @header-height;
		// hardcoded width, as it needs to be as it's fixed positioning
		width: 240px;
        z-index: @z-index-base;
	}

	// since column is on the screen, we no longer need the toggle
	.bsp-trigger-fixed-column {
		display: none;
	}
}

@media @mq-lg {

    & when (@header-positioning = fixed) {

    	body.full-size-header {
    	    padding-top: @header-tophat-height + @header-height-before-scroll;

            .bsp-column-fixed {
                top: @header-tophat-height + @header-height-before-scroll;
            }
    	}

    	body.full-size-header.bsp-scrolling {
    		// adding extra 10px for smoother scrolling user experience
        	padding-top: @header-tophat-height + @header-height + 10px;

            .bsp-column-fixed {
                top: @header-tophat-height + @header-height !important;
            }
    	}
    }

	// up th width to match, has to stay hardcoded as it's fixed positioning
	.bsp-column-fixed {
		width: 317px;
	}

}
